# 容器和容器适配器

_注：本文内容是以流行的观点（特别是C++的STL）来看的。_



## 1. 容器 Container

- 简而言之，容器是存储、管理数据（集合）的一种机制。
- 容器相关的常见操作（接口）有：
  - 容器的建立（初始化） initialization
  - 插入元素 insertion
  - 删除元素 deletion
  - 查询 find
  - 遍历 traverse
  - 统计元素个数 count
  - 检查容器是否为空 empty
- 常用的容器有：
  - 双向链表（链式存储） list
  - 双端队列（顺序存储） deque    //**D**ouble **E**nded **Que**ue的非正规缩写
  - 向量 vector
  - 数组（经过包装而非原生的） array
  - 集合 set
  - 映射 map


## 2.容器适配器 Container Adapter

- 简而言之，容器适配器是依附于别的容器、能转换该容器接口的、适用于特殊场合的“容器”。
- 容器适配器不是一种容器的实现，而是对已有容器的包装。即是说，容器适配器的内部有一个容器对象（称为“基础容器”，underlying container），适配器使用这个容器来管理数据集合。
- 容器适配器的接口是对对应基础容器接口的包装（wrapper），即容器适配器要将操作转发给容器。反过来，为达到次目的，容器必须提供足够的接口。
- 常见的容器适配器有这些：
  - 栈 stack
  
  - 队列 queue
  
    以上两种适配器的默认基础容器是双端队列deque。
- 适配器依赖的容器是可以替换的。你可以用自己编写的、符合规范的容器取替换默认的基础容器。例如，你可以用一个链表代替双端队列。  
- 这里以stack为例来说明情况。
  - stack的基础容器默认为双端队列deque。“双端”意味着，deque可以在前、后两端插入和删除数据。
  - deque的接口
    - push_front()：在队列前端插入数据
    - push_back()：在队列后端插入数据
    - pop_front()：删除队列最前端的数据
    - pop_back()：删除队列最后端的数据
    - front()：获取队列最前端的数据
    - back()：获取队列最后端的数据
    - empty()：判断队列是否为空
  - stack的接口
    - 内部有一个deque对象，既定为c
    - push()：压栈，一般调用c的push_back()
    - pop()：弹栈，一般调用c的pop_back()
    - top()：取栈顶数据，一般调用c的back()
    - empty()：调用c的empty()